# Тестовое задание для отбора на Летнюю ИТ-школу КРОК по разработке

## Условие задания
В теории управления проектами существует такое понятие как стейкхолдер или, иначе говоря, заинтересованная сторона (ЗС). Это лицо, которое может иметь влияние на ход проекта и с чьим мнением нужно считаться по совершенно разным причинам.

Тем не менее, очевидно, что каждый из стейкхолдеров по-своему важен для проекта, что является следствием разного уровня показателей интереса и влияния, потому реакция на обратную связь от каждого из стейкхолдеров определяется в соответствии с матрицей заинтересованных лиц, которая позволяет наглядно определить наиболее и наименее весомых из них.

Чаще всего такая матрица представляет собой график с осями X и Y, где по оси X располагается величина влияния, а по оси Y - величина интереса, и так как значения величин - сугубо неотрицательные числа, работа идет в правом верхнем квадранте. В свою очередь такой срез оси координат делится на 4 части в центрах осей.

Рассмотрим на примере. Допустим, у нас есть 5 ЗС. Первым делом построим ось координат XY и нанесем деления по обеим осям от 0 до 5. Далее поделим пополам каждую из осей (это будут точки (0; 2.5) и (2.5; 0)) и построим пунктирную линию для разделения матрицы на 4 квадранта. Таким образом, мы получим будущую матрицу стейкхолдеров, на которой сможем визуально расположить их по степени влияния и интереса.
![Матрица стейкхолдеров](https://github.com/croc-code/school2024-test-task5/blob/master/stakeholders_matrix.png)

Для того, чтобы определить положение стейкхолдера, используется метод попарного сравнения, схожий с рейтинговыми таблицами в спорте. Строятся матрицы (для интереса и влияния отдельно), в строках и столбцах которых располагаются стейкхолдеры в одинаковом порядке следования, а на пересечении строк и столбцов выставляются значения 0, 0.5 и 1 по следующим правилам:
- 1, если стейкхолдер в текущей строке имеет большее влияние/интерес, чем стейкхолдер в текущем столбце;
- 0.5, если стейкхолдеры в текущих строке и столбце имеют одинаковое влияние/интерес;
- 0, если стейкхолдер в текущей строке имеет меньшее влияние/интерес, чем стейкхолдер в текущем столбце.

По диагоналям значения не выставляются, так как сравнивать стейкхолдера с самим собой некорректно.

Далее полученные величины в строках складываются и получается итоговый ранг заинтересованной стороны. То же самое, но наглядно:
![alt text](https://github.com/croc-code/school2024-test-task5/blob/master/pair_compair.png)

Построив такие матрицы для интереса и влияния, мы получаем “координаты” каждого из стейкхолдеров в матрице и можем расположить в соответствующих квадратах.
Самыми важными для проекта ЗС будут те, что располагаются в правом верхнем квадранте, а те, чье мнение не обязательно учитывать здесь и сейчас, - в левом нижнем.

Вам необходимо реализовать программу, которая по полученным данным матриц влияния и интереса будет определять самых важных стейкхолдеров. В качестве входных данных используются два текстовых файла:
- interest.txt (матрица попарного сравнения стейкхолдеров по уровню интереса)
- influence.txt (матрица попарного сравнения стейкхолдеров по уровню влияния)

Каждый из файлов имеет следующий формат:
- в первой строке файла располагаются наименования заинтересованных сторон, разделенные символов “|”, соответствующие наименованию строк и столбцов матрицы в одинаковом порядке следования;
- последующие строки представляют собой матрицу попарного сравнения со значениями 0, 0.5, 1 в соответствии с правилами формирования;
- на главной диагонали (сравнение ЗС самой с собой) вместо значения идет символ “_”.

Пример содержимого одного из входных файлов:
```
Stakeholder 1 | Stakeholder 2 | Stakeholder 3 | Stakeholder 4 | Stakeholder 5
_ 0 1 0 0
1 _ 0.5 1 1
0 0.5 _ 0 0.5
1 0 1 _ 1
1 0 0.5 0 _
```

В результате работы программа должна сформировать файл (result.txt), в котором будут располагаться самые важные стейкхолдеры (в произвольном порядке). Пример содержимого выходного файла:
```
Stakeholder 1
Stakeholder 3
```

## Автор решения
Самсонов Савелий Артёмович (email: savelij_samsonov@mail.ru)

## Описание реализации
В начале программа с помощью метода getStakeholderList класса StakeholderDataReader отдельно считывает данные из 
входных файлов. Файл с матрицей интереса должен лежать по пути src/main/resources/matrix/interest.txt от корня проекта, 
файл с матрицей влияния - по пути src/main/resources/matrix/influence.txt от корня проекта.

При чтении файла с матрицей интереса/влияния методом readMatrix считывается первая строка, являющаяся шапкой таблицы. 
Подстроки этой строки, разделённые между собой " | ", сохраняются в список как имена стейкхолдеров. Далее считывается n строк 
(n - длина списка имён), каждая разделяется на подстроки, следующие через пробел, и если подстрока не равна "_", 
она преобразовывается в число типа double. Все такие числа, полученные из i-ой строки матрицы после шапки, суммируются 
и записываются в мапу в качестве значения для ключа, равного i-ому элементу в списке имёен стейкхолдеров. 
Если во время работы с файлом прозошла ошибка IOException, то выбросится исключение FileInteractionException, в сообщении 
которого будет указано, при работе с каким файлом возникла ошибка. Предполагается, что каждый из файлов с матрицами 
интереса/влияния имеет корректный вид, описанный в задании.

Таким образом, для матриц интереса и влияния будут получены отдельные мапы вида 
<имя стейкхолдера - значение его интереса/влияния>. После этого наборы ключей этих мап сравниваются методом 
checkStakeholdersSetsEquality, и если они не совпадают, то выбрасывается исключение IncorrectDataException с сообщением
о том, что матрицы не соотвествуют друг другу. Стейкхоледеры могут быть записаны в матрицах в разном порядке, и 
такой случай будет обработан корректно.

Далее данные из этих мап собираются в единый список объектов класса Stakeholder, в которых сохранено имя стейкхолдера, 
значение его интереса и влияния. Метод getStakeholderList класса StakeholderDataReader возращает этот список.

Методом getMostImportantStakeholders класса StakeholderFinder на основе полученного списка ЗС производится поиск самых 
важных стейкхолдеров. Сначала список проверяется методом validateStakeholderList на недоспутимое на равенсто null или 
содержание null как элемента, и если какое-либо из этих условий выполняется, то выбрасывается исключение 
IncorrectDataException с соотвествующим сообщением. Далее вычисляется длина списка стейкхоледеров. Все его элементы, 
удовлетворяющие условию checkIfStakeholderIsMostImportant, которое, учитывая количество стейкхолдеров, проверяет, что 
по координатам интереса и влияния ЗС находится в правом верхнем квадрате (в том числе на его границах с остальными 
квадратами), собираются в новый список. Вновь созданный список возвращается, и метод getMostImportantStakeholders 
завершает работу.

С помощью метода writeStakeholderNames класса StakeholderDataWriter имена стейкхолдеров из составленного списка самых 
важных ЗС записываются в файл ответа, располагющийся по пути src/main/resources/result.txt от корня проекта. Если файл 
по такому пути уже существует, то он удаляется и создаётся новый, в который по одному на строке записываются имена ЗС 
из предоставленного списка самых важных ЗС. Если во время работы с файлом произошла ошибка IOException, то выбросится 
исключение FileInteractionException, в сообщении которого будет указано, при работе с каким файлом возникла ошибка.

Если во время работы выбросится исключение FileInteractionException или IncorrectDataException, то программа завершит 
работу, выведя его сообщение в консоль.

Для тестирования работы программы написаны тесты, расположенные в src/test/java/ru/croc. GetStakeholderListTest 
тестирует чтение списка ЗС из файлов, StakeholderFinderTest тестирует нахождение самых важных ЗС из общего списка ЗС.

## Инструкция по сборке и запуску решения
Необходимая версия джавы: 17+.

Склонировать репозиторий, заполнить файлы src/main/resources/matrix/interest.txt и 
src/main/resources/matrix/influence.txt нужными данными.
Запустить программу в ОС Windows можно 2 способами:
1. С использованием IntelliJ Idea: открыть проект в IDE, запустить класс Main
2. Через командную строку: \
Установить jdk17 (https://www.oracle.com/java/technologies/javase/jdk17-archive-downloads.html) \
Удостовериться, что в переменных среды в JAVA_HOME задан путь к jdk17 \
Через командную строку в корневой папке проекта выполнить команды gradlew clean build, gradlew run.
